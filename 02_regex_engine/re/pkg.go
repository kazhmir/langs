package re

import (
	"fmt"
	"io"
	"log"
	"strings"
)

/*Action is a function that receives a pointer to the machine Head
Actions are called on accepting states, according to syntax
*/
type Action func(*Match) (stop bool)

/*Machine is the automaton generated by the Build function
It contains structural data regarding the underlying automaton
*/
type Machine struct {
	Start   *state
	Pattern string
	Syntax  map[string]Action
}

func (m *Machine) String() string {
	dt := &map[*state]int{}
	m.Start.Enum(dt)
	return m.Pattern + "\n" + prettyPrint(dt) + "\n"
}

//Run creates a machine Head and runs the string through the automaton.
func (m *Machine) Run(txt io.RuneReader) error {
	return nil
}

//Run creates a machine Head and runs the string through the automaton.
func (m *Machine) RunStr(str string) error {
	txt := strings.NewReader(str)
	return m.Run(txt)
}

type Match struct {
	S          string
	Start, End int
	act        Action
}

func (m *Match) String() string {
	return fmt.Sprintf("%v:%v{\"%v\", %v}", m.Start, m.End, m.S, m.act)
}

type Head struct {
	Curr []*state
	set  map[*state]struct{}
}

func (h *Head) Consume(r rune) {
	add := []*state{}
	for _, st := range h.Curr {
		if st.act != nil { // is accepting state

		}
		next := st.move(r)
		if next != nil {
			if _, ok := h.set[next]; !ok {
				add = append(add, next)
				h.set[next] = struct{}{}
			}
		}
	}
}

func (h *Head) Match() {}

/*BuildOne returns a machine for a single pattern and action.
 */
func BuildOne(pattern string, act Action) *Machine {
	start := compile(pattern, act).start
	return &Machine{
		Start:   start,
		Pattern: pattern,
		Syntax:  map[string]Action{pattern: act},
	}
}

/*Build creates a machine with many patterns and actions.
The regexes are built one by one and joined through alternation '|'.
*/
func Build(syntax map[string]Action) *Machine {
	atmts := make([]*automaton, len(syntax))
	patterns := make([]string, len(syntax))
	i := 0
	//this can be paralelized
	for re, act := range syntax {
		patterns[i] = re
		atmts[i] = compile(re, act)
		i++
	}
	final := &automaton{}
	for _, atmt := range atmts { // joining through alternation
		atmt.acc.addEmptyTr(final.acc)
		final.start.addEmptyTr(atmt.start)
	}
	final.start.Enum(&map[*state]int{})
	start := powerSet(&map[string]*state{}, final.start)
	return &Machine{
		Start:   start,
		Pattern: strings.Join(patterns, "|"),
		Syntax:  syntax,
	}
}

func compile(pattern string, act Action) *automaton {
	if act == nil {
		log.Fatal("Action cannot be nil")
	}
	tokens := lexString(pattern)
	p := &parser{}
	root := p.run(tokens)
	fmt.Println(root)
	atmt := createAtmt(root)
	atmt.acc.act = act
	mp := map[*state]int{}
	atmt.start.Enum(&mp)
	fmt.Println("thomps:", prettyPrint(&mp))

	atmt.start = powerSet(&map[string]*state{}, atmt.start)
	mp = map[*state]int{}
	atmt.start.Enum(&mp)
	fmt.Println("powerset:", prettyPrint(&mp))

	return atmt
}
